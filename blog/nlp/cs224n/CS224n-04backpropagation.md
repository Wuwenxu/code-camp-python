# 【2019斯坦福CS224N笔记】（4）反向传播

csdn：https://blog.csdn.net/abcgkj

github：https://github.com/aimi-cn/AILearners

---

上节课我们主要讲述了神经网络的一些基础知识和命名实体识别。但到目前为止，我们还没有对训练过程中的参数做出过多的描述。那么我们是如何对参数进行更新的呢？这就是本文的主题————反向传播。

![](../../../img/nlp/cs224n/04backPropagation/Error_surface_of_a_linear_neuron_with_two_input_weights.png)

那么什么是反向传播呢？

维基百科上是这样定义的：反向传播是（英语：Backpropagation，缩写为BP）“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。该方法对网络中所有权重计算损失函数的梯度。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。而反向传播中运用到的理论，其实就是我们熟知的链式求导法则而已。因此，这就要求人工神经元（或“节点”）的激励函数可微。

在讲反向传播之前，我们先看一张非常熟悉的图：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630140644406-409859737.png)

这是典型的三层神经网络的基本构成，Layer L1是输入层，Layer L2是隐含层，Layer L3是隐含层，我们现在手里有一堆数据{x1,x2,x3,...,xn},输出也是一堆数据{y1,y2,y3,...,yn},现在要他们在隐含层做某种变换，让你把数据灌进去后得到你期望的输出。如果你希望你的输出和原始输入一样，那么就是最常见的自编码模型（Auto-Encoder）。可能有人会问，为什么要输入输出都一样呢？有什么用啊？其实应用挺广的，在图像识别，文本分类等等都会用到，我会专门再写一篇Auto-Encoder的文章来说明，包括一些变种之类的。如果你的输出和原始输入不一样，那么就是很常见的人工神经网络了，相当于让原始数据通过一个映射来得到我们想要的输出数据，也就是我们今天要讲的话题。

本文直接举一个例子，带入数值演示反向传播法的过程，

假设，你有这样一个网络层：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630141449671-1058672778.png)

第一层是输入层，包含两个神经元i1，i2，和截距项b1；第二层是隐含层，包含两个神经元h1,h2和截距项b2，第三层是输出o1,o2，每条线上标的wi是层与层之间连接的权重，激活函数我们默认为sigmoid函数。

现在对他们赋上初值，如下图：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630142019140-402363317.png)

其中，输入数据  i1=0.05，i2=0.10;

输出数据 o1=0.01,o2=0.99;

初始权重  w1=0.15,w2=0.20,w3=0.25,w4=0.30;

w5=0.40,w6=0.45,w7=0.50,w8=0.55

目标：给出输入数据i1,i2(0.05和0.10)，使输出尽可能与原始输出o1,o2(0.01和0.99)接近。

**Step 1 前向传播**

1.输入层---->隐含层：

计算神经元h1的输入加权和：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630142915359-294460310.png)

神经元h1的输出o1:(此处用到激活函数为sigmoid函数)：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630150115390-1035378028.png)

　　同理，可计算出神经元h2的输出o2：

　　![](../../../img/nlp/cs224n/04backPropagation/853467-20160630150244265-1128303244.png)

　　2.隐含层---->输出层：

　　计算输出层神经元o1和o2的值：

　　![](../../../img/nlp/cs224n/04backPropagation/853467-20160630150517109-389457135.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630150638390-1210364296.png)

这样前向传播的过程就结束了，我们得到输出值为[0.75136079 , 0.772928465]，与实际值[0.01 , 0.99]相差还很远，现在我们对误差进行反向传播，更新权值，重新计算输出。

**Step 2 反向传播**

1.计算总误差

总误差：(square error)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630151201812-1014280864.png)

但是有两个输出，所以分别计算o1和o2的误差，总误差为两者之和：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630151457593-1250510503.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630151508999-1967746600.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630151516093-1257166735.png)

2.隐含层---->输出层的权值更新：

以权重参数w5为例，如果我们想知道w5对整体误差产生了多少影响，可以用整体误差对w5求偏导求出：（链式法则）

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630151916796-1001638091.png)

下面的图可以更直观的看清楚误差是怎样反向传播的：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152018906-1524325812.png)

现在我们来分别计算每个式子的值：

计算：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152206781-7976168.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152258437-1960839452.png)

计算：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152417109-711077078.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152511937-1667481051.png)

（这一步实际上就是对sigmoid函数求导，比较简单，可以自己推导一下）

计算!

[](../../../img/nlp/cs224n/04backPropagation/853467-20160630152625593-2083321635.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152658109-214239362.png)

最后三者相乘：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630152811640-888140287.png)

这样我们就计算出整体误差E(total)对w5的偏导值。

回过头来再看看上面的公式，我们发现：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153103187-515052589.png)

为了表达方便，用以下符号来表示输出层的误差：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153202812-585186566.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153251234-1144531293.png)

因此，整体误差E(total)对w5的偏导公式可以写成：

![](../../../img/nlp/cs224n/04backPropagation/-20160630153405296-436656179.png)

如果输出层误差计为负的话，也可以写成：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153514734-1544628024.png)

最后我们来更新w5的值：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153614374-1624035276.png)

（其中，η是学习速率，这里我们取0.5）

同理，可更新w6,w7,w8:

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630153807624-1231975059.png)

3.隐含层---->隐含层的权值更新：

　方法其实与上面说的差不多，但是有个地方需要变一下，在上文计算总误差对w5的偏导时，是从out(o1)---->net(o1)---->w5,但是在隐含层之间的权值更新时，是out(h1)---->net(h1)---->w1,而out(h1)会接受E(o1)和E(o2)两个地方传来的误差，所以这个地方两个都要计算。

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630154317562-311369571.png)

计算

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630154712202-1906007645.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630154758531-934861299.png)

先计算

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630154958296-1922097086.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155015546-1106216279.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155036406-964647962.png)

![](.../../../img/nlp/cs224n/04backPropagation/853467-20160630155117656-1905928379.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155158468-157032005.png)

同理，计算出：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155310937-2103938446.png)

两者相加得到总值：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155435218-396769942.png)

再计算

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155555562-1422254830.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155628046-229505495.png)

再计算

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155731421-239852713.png)

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155706437-964861747.png)

最后，三者相乘：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630155827718-189457408.png)

 为了简化公式，用sigma(h1)表示隐含层单元h1的误差：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630160345281-679307550.png)

最后，更新w1的权值：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630160523437-1906004593.png)

同理，额可更新w2,w3,w4的权值：

![](../../../img/nlp/cs224n/04backPropagation/853467-20160630160603484-1471434475.png)

这样误差反向传播法就完成了，最后我们再把更新的权值重新计算，不停地迭代，在这个例子中第一次迭代之后，总误差E(total)由0.298371109下降至0.291027924。迭代10000次后，总误差为0.000035085，输出为[0.015912196,0.984065734](原输入为[0.01,0.99]),证明效果还是不错的。

## 小结

本节内容我们从一个实例解释了一下反向传播算法。其实要理解反向传播并不难，我们只要熟悉链式求导法则，并且静下心来一步步的推导一遍，就会理解反向传播真正奥秘了。

本文内容来源于：

* 原文作者：Charlotte77 
* 出处：http://www.cnblogs.com/charlotte77/ 
* 如有侵权，请联系我们。